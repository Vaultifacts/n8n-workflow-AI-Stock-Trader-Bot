{
  "name": "AI_Stock_Trader_Bot",
  "nodes": [
    {
      "parameters": {
        "updates": [
          "message"
        ],
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.2,
      "position": [
        -1088,
        368
      ],
      "id": "ee944ce7-c880-4fb6-b5f1-a0bbf38a8c3e",
      "name": "TelegramInputTrigger",
      "webhookId": "fd100b2b-8fc2-4dbb-89d4-ef0b4f580178",
      "credentials": {
        "telegramApi": {
          "id": "SEtfhHTHn4V1lCk0",
          "name": "DayTraderBotCredential"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get all input items from upstream (e.g., Telegram trigger)\nconst items = $input.all();\n\n// Defensive check: If no items, return an empty item with default symbol\nif (items.length === 0) {\n  return [\n    {\n      json: {\n        symbol: ''  // Default empty to avoid downstream errors\n      }\n    }\n  ];\n}\n\n// Process each item\nfor (const item of items) {\n  // Defensive check: Ensure message.text exists\n  const messageText = item.json?.message?.text || '';  // Fallback to empty string if missing\n  item.json.symbol = messageText.trim().toUpperCase();  // Trim and uppercase (e.g., \" tsla \" -> \"TSLA\")\n}\n\n// Return the updated items\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -432,
        368
      ],
      "id": "c44ea853-4c02-4f75-99ae-ce7fa38a80e9",
      "name": "NormalizeInputText"
    },
    {
      "parameters": {
        "jsCode": "let normalizedText = '';\n\n// Validate input structure\nif (items.length > 0 && items[0] && items[0].json && typeof items[0].json.symbol === 'string') {\n  normalizedText = items[0].json.symbol;\n} else {\n  // Debug log for missing data; can be removed in production\n  console.log('No valid symbol field found in input items');\n  return [];\n}\n\nconst symbols = normalizedText.split(',').map(s => s.trim()).filter(s => s.length > 0); // Split, trim, and filter empty entries\n\n// Create new items for each symbol\nreturn symbols.map(symbol => ({ json: { symbol } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -208,
        368
      ],
      "id": "7991cb42-1101-4982-8688-12077c00a1dc",
      "name": "ParseSymbolsToArray"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        16,
        368
      ],
      "id": "e5c5bc2f-fbf7-48ae-b629-12f1cdef083b",
      "name": "LoopValidateSymbols",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "fefb87f7-aceb-42e9-9cae-dcb77038dbbf",
              "leftValue": "={{ $node[\"NormalizeInputText\"].item.json[\"symbol\"] }}",
              "rightValue": "=/^([A-Z]{1,5}(\\\\.[A-Z]{1,2})?(,\\\\s*)?)+$/",
              "operator": {
                "type": "string",
                "operation": "regex"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        240,
        208
      ],
      "id": "03fb5f7c-89a9-41e0-b630-ec4eda5b0825",
      "name": "CheckSymbolRegex"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "c61eb9ff-6361-4bea-874f-2c9edbad4430",
              "leftValue": "={{$node[\"ValidateSymbolTwelveData\"].json[\"data\"].length}}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        912,
        48
      ],
      "id": "3a83cf7a-e45c-4e91-8fd1-143207af141d",
      "name": "CheckSymbolAPIResult"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "name": "AddRateLimitWait",
      "typeVersion": 1,
      "position": [
        240,
        512
      ],
      "id": "56c78d1c-43e0-4586-9ee9-74137d204299"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1584,
        112
      ],
      "id": "23aa3d12-fc66-4161-96a7-7216300cbf65",
      "name": "MergeValidationResults"
    },
    {
      "parameters": {
        "chatId": "={{ $('TelegramInputTrigger').first().json.message.chat.id }}",
        "text": "Invalid stock symbol provided. Please enter a valid ticker (e.g., AAPL) and try again.",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        1360,
        208
      ],
      "id": "ca8ea928-3eed-4445-9beb-189679976d0d",
      "name": "SendErrorMessage",
      "webhookId": "c0f03da0-d6a3-4848-9ffd-9e3351f3eb08",
      "credentials": {
        "telegramApi": {
          "id": "SEtfhHTHn4V1lCk0",
          "name": "DayTraderBotCredential"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get all input items from upstream (e.g., from ValidateSymbolTwelveData)\nconst items = $input.all();\n\n// Defensive check: If no items, return default output\nif (items.length === 0) {\n  return [\n    {\n      json: {\n        validSymbols: [],\n        errorString: 'No input items received. Check upstream nodes.'\n      }\n    }\n  ];\n}\n\n// Initialize arrays\nlet validSymbols = [];\nlet errors = [];\n\n// Process each item\nfor (const item of items) {\n  // Defensive check: Ensure item.json exists\n  if (!item.json) {\n    errors.push('Item missing json data');\n    continue;\n  }\n\n  // Fallback to nested API structure for symbol (from your API output: data[0].symbol)\n  const symbol = item.json.symbol || item.json.data?.[0]?.symbol || item.json.search_symbol || '';  // Fallback chain\n  const normalizedSymbol = symbol.toUpperCase().trim();\n\n  // Skip if no symbol found (prevents \"missing symbol\" for empty items)\n  if (!normalizedSymbol) {\n    // Optional: Comment out the push if you don't want to log empty items\n    // errors.push('Item missing symbol');\n    continue;  // Skip to next item\n  }\n\n  // Check if valid (based on API \"status\": \"ok\" from your API output)\n  if (item.json.status === 'ok' || !item.json.errors || item.json.errors.length === 0) {\n    validSymbols.push(normalizedSymbol);\n  } else if (Array.isArray(item.json.errors) && item.json.errors.length > 0) {\n    errors = errors.concat(item.json.errors);\n  } else {\n    errors.push('Unexpected item structure or API error: ' + (item.json.message || 'Unknown'));\n  }\n}\n\n// Remove duplicates from validSymbols\nvalidSymbols = [...new Set(validSymbols)];\n\n// Build errorString only if there are errors\nconst errorString = errors.length > 0\n  ? `Invalid symbols or issues: ${errors.join(', ')}. Proceeding with valid ones: ${validSymbols.join(', ') || 'None'}.`\n  : '';\n\n// Return single item output\nreturn [\n  {\n    json: {\n      validSymbols: validSymbols,\n      errorString: errorString\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1808,
        112
      ],
      "id": "76c29c83-58a7-41cd-a6b7-ff5e346808be",
      "name": "FormatValidSymbols"
    },
    {
      "parameters": {
        "url": "https://api.twelvedata.com/time_series",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "symbol",
              "value": "={{$json.symbol}}"
            },
            {
              "name": "interval",
              "value": "1min"
            },
            {
              "name": "outputsize",
              "value": "100"
            },
            {
              "name": "apikey",
              "value": "03b82e9068bf43118f3b04858762bf49"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2032,
        -144
      ],
      "id": "44b8434a-1cea-44d8-be23-c105d2b7331e",
      "name": "Fetch1MinTimeSeries",
      "credentials": {
        "httpQueryAuth": {
          "id": "srLxuSkG3qoi2f8B",
          "name": "TwelveDataAPI"
        }
      }
    },
    {
      "parameters": {
        "url": "https://api.twelvedata.com/time_series",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "symbol",
              "value": "={{$json.symbol}}"
            },
            {
              "name": "interval",
              "value": "15min"
            },
            {
              "name": "outputsize",
              "value": "100"
            },
            {
              "name": "apikey",
              "value": "03b82e9068bf43118f3b04858762bf49"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2032,
        48
      ],
      "id": "07adb778-4fcd-42a5-ac59-0472379738ef",
      "name": "Fetch15MinTimeSeries",
      "credentials": {
        "httpQueryAuth": {
          "id": "srLxuSkG3qoi2f8B",
          "name": "TwelveDataAPI"
        }
      }
    },
    {
      "parameters": {
        "url": "https://api.twelvedata.com/time_series",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "symbol",
              "value": "={{$json.symbol}}"
            },
            {
              "name": "interval",
              "value": "1h"
            },
            {
              "name": "outputsize",
              "value": "100"
            },
            {
              "name": "apikey",
              "value": "03b82e9068bf43118f3b04858762bf49"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2032,
        240
      ],
      "id": "bab7ba61-76f8-4630-b824-6816c3513945",
      "name": "Fetch1HourTimeSeries",
      "credentials": {
        "httpQueryAuth": {
          "id": "srLxuSkG3qoi2f8B",
          "name": "TwelveDataAPI"
        }
      }
    },
    {
      "parameters": {
        "url": "https://newsapi.org/v2/everything",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "qInTitle",
              "value": "={{$json.symbol}}"
            },
            {
              "name": "from",
              "value": "={{ new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] }}"
            },
            {
              "name": "language",
              "value": "en"
            },
            {
              "name": "sortBy",
              "value": "publishedAt"
            },
            {
              "name": "pageSize",
              "value": "5"
            },
            {
              "name": "q",
              "value": "={{$json.symbol}} +stock OR +earnings OR +market"
            },
            {
              "name": "apikey",
              "value": "=23bf725d79954f49b5dcbfce35f52cbe"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2480,
        384
      ],
      "id": "f4647b7f-86a4-40cd-b12a-7a1062aba507",
      "name": "FetchNewsArticles",
      "credentials": {
        "httpQueryAuth": {
          "id": "qTO2AXW1jyzkqDKZ",
          "name": "NewsAPI"
        },
        "httpHeaderAuth": {
          "id": "Dm2QVIWXvdZ37UmD",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get all input items from upstream (e.g., invalid symbols from validation)\nconst items = $input.all();\n\n// Defensive check: If no items, return a default item with empty errors\nif (items.length === 0) {\n  return [\n    {\n      json: {\n        errors: []  // Empty array to avoid downstream errors\n      }\n    }\n  ];\n}\n\n// Use the first item as the aggregator (your original approach)\nconst aggregator = items[0];\n\n// Defensive check: Ensure aggregator has json and errors array\nif (!aggregator.json) {\n  aggregator.json = {};  // Create if missing\n}\nif (!Array.isArray(aggregator.json.errors)) {\n  aggregator.json.errors = [];  // Initialize if missing or not array\n}\n\n// Process each item (original line 5 fixed)\nfor (const item of items) {\n  // Defensive check: Skip if item.json or symbol is missing\n  if (!item.json || typeof item.json.symbol === 'undefined') {\n    continue;  // Skip this item gracefully (or add a default: aggregator.json.errors.push('Unknown invalid symbol'))\n  }\n\n  // Append the invalid symbol message\n  aggregator.json.errors.push(item.json.symbol + ' is invalid');\n}\n\n// Return only the aggregator item (single item output)\nreturn [aggregator];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        208
      ],
      "id": "4c27d041-c82f-47f3-9f41-dd58cee7afa3",
      "name": "CollectInvalidSymbol"
    },
    {
      "parameters": {
        "url": "=https://api.twelvedata.com/symbol_search?symbol={{$json.symbol}}&outputsize=1",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "03b82e9068bf43118f3b04858762bf49"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        464,
        48
      ],
      "id": "b139043d-d7f4-4f3b-aea5-e879fb2ce833",
      "name": "ValidateSymbolTwelveData",
      "credentials": {
        "httpQueryAuth": {
          "id": "srLxuSkG3qoi2f8B",
          "name": "TwelveDataAPI"
        }
      }
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        3120,
        48
      ],
      "id": "7ba9c8e8-d4dc-44e7-887e-f6627407e676",
      "name": "AggregateDataIntervals"
    },
    {
      "parameters": {
        "jsCode": "// Input: Nested array from upstream\n// Output: Per-symbol with sorted values, added sma20/rsi14\nfunction flattenDeep(arr) {\n  return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);\n}\n\nconst items = $input.all();\nif (items.length === 0) {\n  return [{ json: { error: 'No data from upstream.' } }];\n}\n\nlet symbolData = items[0]?.json?.data?.[0]?.data || [];\nif (symbolData.length === 0) {\n  const allFlat = flattenDeep(items.map(item => item.json));\n  symbolData = allFlat.filter(item => item && item.symbol);\n}\nif (symbolData.length === 0) {\n  return [{ json: { error: 'No symbol data found.' } }];\n}\n\nconst formatted = symbolData.map(symbolItem => {\n  const symbol = symbolItem.symbol || 'Unknown';\n  const intervals = symbolItem.intervals || {};\n  const updatedIntervals = {};\n\n  for (const intervalKey in intervals) {\n    const intervalData = intervals[intervalKey] || {};\n    let values = intervalData.values || [];\n    if (values.length === 0) {\n      updatedIntervals[intervalKey] = { ...intervalData, values: [], error: 'No values.' };\n      continue;\n    }\n\n    values = values.sort((a, b) => new Date(a.datetime) - new Date(b.datetime));\n\n    const closes = values.map(c => parseFloat(c.close) || 0);\n\n    function calculateSMA(closes, period = 20) {\n      return closes.map((_, index) => {\n        if (index < period - 1) return null;\n        const slice = closes.slice(index - period + 1, index + 1);\n        const sum = slice.reduce((total, val) => total + val, 0);\n        return (sum / period).toFixed(2);\n      });\n    }\n    const smaValues = calculateSMA(closes);\n\n    function calculateRSI(closes, period = 14) {\n      if (closes.length < period) return new Array(closes.length).fill(null);\n\n      const changes = [];\n      for (let i = 1; i < closes.length; i++) {\n        changes.push(closes[i] - closes[i - 1]);\n      }\n\n      let avgGain = changes.slice(0, period).reduce((sum, ch) => sum + (ch > 0 ? ch : 0), 0) / period;\n      let avgLoss = Math.abs(changes.slice(0, period).reduce((sum, ch) => sum + (ch < 0 ? ch : 0), 0) / period);\n\n      const rsi = new Array(period - 1).fill(null);\n      if (avgLoss === 0) rsi.push(100);\n      else if (avgGain === 0) rsi.push(0);\n      else rsi.push((100 - (100 / (1 + (avgGain / avgLoss)))).toFixed(2));\n\n      for (let i = period; i < changes.length; i++) {\n        const currGain = changes[i] > 0 ? changes[i] : 0;\n        const currLoss = changes[i] < 0 ? Math.abs(changes[i]) : 0;\n        avgGain = (avgGain * (period - 1) + currGain) / period;\n        avgLoss = (avgLoss * (period - 1) + currLoss) / period;\n        if (avgLoss === 0) rsi.push(100);\n        else if (avgGain === 0) rsi.push(0);\n        else rsi.push((100 - (100 / (1 + (avgGain / avgLoss)))).toFixed(2));\n      }\n      return rsi;\n    }\n    const rsiValues = calculateRSI(closes);\n\n    const updatedValues = values.map((candle, index) => ({\n      ...candle,\n      sma20: smaValues[index],\n      rsi14: rsiValues[index]\n    }));\n\n    updatedIntervals[intervalKey] = { ...intervalData, values: updatedValues };\n  }\n\n  return {\n    json: {\n      symbol,\n      intervals: updatedIntervals,\n      news: symbolItem.news || {}\n    }\n  };\n});\n\nreturn formatted;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3408,
        48
      ],
      "id": "f26c2700-627a-4c09-8597-21de6611042b",
      "name": "ComputeTechnicalIndicators"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a highly intelligent and accurate sentiment analyzer specializing in the financial markets. Analyze the sentiment of the provided news articles for the stock symbol(s) mentioned.\n\n- Evaluate the immediate market reaction, recent news impact, and technical volatility based on all articles.\n- Aggregate sentiments if multiple articles: Weigh recent/major events more heavily.\n- Determine an overall sentiment category: \"Positive\", \"Neutral\", or \"Negative\".\n- Calculate a numerical score between -1 (extremely negative) and 1 (extremely positive), averaging across articles.\n- Provide a concise rationale explaining the short-term sentiment (detailed, with headlines for major events; 2-4 sentences).\n\nIf no articles or irrelevant content: Use category \"Neutral\", score 0, rationale \"No relevant news found.\"\n\nYour output must be exactly a JSON object wrapped in \"shortTermSentiment\", with three keys: \"category\", \"score\", and \"rationale\". Do not output any additional text or explanations.\n\nExample output:\n{\n  \"shortTermSentiment\": {\n    \"category\": \"Positive\",\n    \"score\": 0.7,\n    \"rationale\": \"Tesla's strong earnings beat led to a 10% surge, indicating positive market reaction despite volatility. Headline: 'TSLA Earnings Smash Expectations'.\"\n  }\n}\n\nNow, analyze the following articles and produce your JSON output: {{ JSON.stringify($json.articles) }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a highly intelligent and accurate sentiment analyzer specializing in the financial markets. Analyze the sentiment of the provided news articles for the stock symbol(s) mentioned.\n\n- Evaluate the immediate market reaction, recent news impact, and technical volatility based on all articles.\n- Aggregate sentiments if multiple articles: Weigh recent/major events more heavily.\n- Determine an overall sentiment category: \"Positive\", \"Neutral\", or \"Negative\".\n- Calculate a numerical score between -1 (extremely negative) and 1 (extremely positive), averaging across articles.\n- Provide a concise rationale explaining the short-term sentiment (detailed, with headlines for major events; 2-4 sentences).\n\nIf no articles or irrelevant content: Use category \"Neutral\", score 0, rationale \"No relevant news found.\"\n\nYour output must be exactly a JSON object wrapped in \"shortTermSentiment\", with three keys: \"category\", \"score\", and \"rationale\". Do not output any additional text or explanations.\n\nExample output:\n{\n  \"shortTermSentiment\": {\n    \"category\": \"Positive\",\n    \"score\": 0.7,\n    \"rationale\": \"Tesla's strong earnings beat led to a 10% surge, indicating positive market reaction despite volatility. Headline: 'TSLA Earnings Smash Expectations'.\"\n  }\n}\n\nNow, analyze the following articles and produce your JSON output: {{ JSON.stringify($json.articles) }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.9,
      "position": [
        2928,
        480
      ],
      "id": "08af3dc7-d832-427c-8f21-eef0de6b403b",
      "name": "AnalyzeNewsSentimentChain"
    },
    {
      "parameters": {
        "model": "grok-3-mini",
        "options": {
          "maxTokens": 300,
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatXAiGrok",
      "typeVersion": 1,
      "position": [
        3008,
        704
      ],
      "id": "554924eb-c979-4ddc-8539-49ca41e1fc3a",
      "name": "GrokSentimentModel",
      "credentials": {
        "xAiApi": {
          "id": "LnJS5l9C6NoeRvcL",
          "name": "xAi account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3696,
        320
      ],
      "id": "a380b1a7-36a3-4cf0-a087-328939433798",
      "name": "MergeSentimentResults"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        4128,
        320
      ],
      "id": "1962b459-4565-4451-84c2-7baa28b136e2",
      "name": "AggregateSentimentScores"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an expert day trader. Using the data below, please give a single, unified trade recommendation -Buy, Sell, or Hold-based on both price action (1m, 15m, 1h candles) and 24h sentiment. Then provide:\n\n- Ticker Symbol\n- Technical Recommendation (Buy, Sell, or Hold; Incorporating candle analysis and sentiment)\n- Entry Price\n- Stop-Loss\n- Target/Exit Price\n\nProvide your answer as plain text with bullet points and clear line breaks.\n\nTechnical Data (candles):\n{{ JSON.stringify($json.data[0]) }}\n\nSentiment Analysis (Past 24h):\n{{ JSON.stringify($json.data[1]) }}\n\nEach candle object has:\n- timeframe: \"1m\", \"15m\", or \"1h\"\n- candles: [openTime, open, high, low, close, volume, ...]\n\nSteps for the agent:\n1. Group candles by timeframe (1m, 15m, 1h).\n2. Use 1m & 15m action + indicators (RSI, MACD, Trendlines) for optimal entry.\n3. Confirm trend with 1h data.\n4. Factor in sentiment to refine the Buy/Sell/Hold call.\n\n### Response format (no extra text!):\n- Technical Recommendation: <BUY|SELL|HOLD>\n- Entry Price: <number>\n- Stop-Loss: <number>\n- Target/Exit Price: <number>",
        "options": {
          "systemMessage": "You are an expert day trader. ONLY output exactly the lines below-no rationale, no extra commentary.\n\n### Response format (absolutely no other text!)\n- Ticker Symbol: <string>\n- Technical Recommendation: <BUY|SELL|HOLD>\n- Entry Price: <number or N/A>\n- Stop-Loss: <number or N/A>\n- Target/Exit: <number or N/A>\n- Hold or Exit Decision: <Hold|Exit>"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        4352,
        320
      ],
      "id": "aaae121d-601b-4cba-8a99-9e96657d7e3d",
      "name": "GenerateTradeRecommendationAgent"
    },
    {
      "parameters": {
        "model": "grok-4-fast-reasoning",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatXAiGrok",
      "typeVersion": 1,
      "position": [
        4432,
        544
      ],
      "id": "1911db9c-dce1-4ce1-9dbf-e2c0f0c79069",
      "name": "GrokRecommendationModel",
      "credentials": {
        "xAiApi": {
          "id": "LnJS5l9C6NoeRvcL",
          "name": "xAi account"
        }
      }
    },
    {
      "parameters": {
        "chatId": "=8511306269",
        "text": "={{$json.output}}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        4704,
        320
      ],
      "id": "fbac985f-c858-4956-b418-a83ae4240650",
      "name": "SendTradeRecommendation",
      "webhookId": "3a473a39-4dab-4d1a-bc56-9da99d0fdd63",
      "credentials": {
        "telegramApi": {
          "id": "SEtfhHTHn4V1lCk0",
          "name": "DayTraderBotCredential"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.4,
      "position": [
        2496,
        576
      ],
      "id": "cf6de127-2578-4504-8e0d-60869941ec37",
      "name": "HandleIncomingChatMessage",
      "webhookId": "c7edf6a6-a06a-4b0f-b2e7-b5edc108f3e2"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "f921eb93-b7e9-454d-ad33-fe796ea3c633",
              "name": "inputSymbol",
              "value": "={{ $json.symbol }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        240,
        -16
      ],
      "id": "e3552212-5e5f-4df8-a9de-df62d8e82f54",
      "name": "PreserveSymbol"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "8d25f461-3c1b-4e68-bf02-933896a04cf4",
              "leftValue": "={{ $json.message.text }}",
              "rightValue": "This message was sent automatically with n8n",
              "operator": {
                "type": "string",
                "operation": "notContains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -656,
        288
      ],
      "id": "2e56eafb-f70a-4abd-a6e3-1179b4ffa8a0",
      "name": "FilterBotMessages"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        688,
        48
      ],
      "id": "d2a1863b-7b9c-4005-a00c-28e9abf739d0",
      "name": "RateLimitWait",
      "webhookId": "4dfa7b44-1e06-4b3e-8590-a6914c110e99"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2256,
        -144
      ],
      "id": "186d7c11-52ff-44a0-8dcf-44849400e9e5",
      "name": "RateLimit1Min",
      "webhookId": "c617d089-7f02-4969-9929-7b0002a40908"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2256,
        48
      ],
      "id": "7157be21-2af9-460d-8d16-740b3a7da8ea",
      "name": "RateLimit15Min",
      "webhookId": "0a81b84f-fc73-4cf6-8761-d25bf08fec83"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2256,
        240
      ],
      "id": "59cbc95b-5485-4f07-b627-69b723834efe",
      "name": "RateLimit1Hr",
      "webhookId": "609b0d97-84ee-4d13-8dd2-39207fddfca0"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2704,
        384
      ],
      "id": "6c0d75b0-a9ff-4d45-b825-9d180ebe56bd",
      "name": "RateLimitNews",
      "webhookId": "2f0e746f-6175-401d-b06b-2c050ebeddb8"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2896,
        32
      ],
      "id": "a4c443b4-8572-4424-b471-19da8e823e74",
      "name": "AggregateTimeSeries"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        3904,
        320
      ],
      "id": "8c85ef28-a63b-4df8-9f85-4488f0b1b7da",
      "name": "AggregateSentiments"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "33b12192-c967-4f2a-97c6-7dfa02ba3a31",
              "name": "chatId",
              "value": "={{$json.message.chat.id}}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -880,
        368
      ],
      "id": "64fc15a3-ee3f-4499-8168-0702118d0197",
      "name": "PreserveChatId"
    },
    {
      "parameters": {
        "jsCode": "// Input: Object with validSymbols array (e.g., from FormatValidSymbols)\n// Output: Array of individual symbol objects (e.g., [{symbol: \"TSLA\"}, {symbol: \"AAPL\"}])\n// Dependencies: None (native JS). This is a fallback for loop splitting.\n\nconst input = $input.first().json;\nconst symbols = input.validSymbols || [];  // Get array or empty if missing\n\nif (symbols.length === 0) {\n  return [{ json: { error: 'No valid symbols found. Check upstream validation.' } }];\n}\n\n// Map to individual items\nreturn symbols.map(symbol => ({ json: { symbol: symbol.trim().toUpperCase() } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1808,
        -16
      ],
      "id": "cc6f8010-d2aa-42c3-9620-edd948d3bf60",
      "name": "ManualSymbolSplit"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "numberInputs": 4,
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2480,
        32
      ],
      "id": "e5910da5-66eb-44eb-b588-ef9c47a209a1",
      "name": "MergeFetchResults"
    },
    {
      "parameters": {
        "jsCode": "// Input: Merged array of time series and news for symbols (e.g., [ {meta:..., values:..., articles:...}, {meta:..., values:..., articles:...} ])\n// Output: Structured array per symbol, e.g., [{symbol: \"TSLA\", intervals: {1h: {values: [...]}}, news: {articles: [...]}}]\n// Why: Handles current input without labels; beginner-friendly with error checks.\n\nconst items = $input.all();  // Get all merged items (one per symbol)\n\nif (items.length === 0) {\n  return [{ json: { error: 'No merged data. Check fetch nodes.' } }];\n}\n\nconst formatted = items.map(item => {\n  const data = item.json;\n\n  // Extract symbol from meta (fallback if missing)\n  const symbol = data.meta?.symbol || 'Unknown';\n\n  // Assume this is 1h interval; adjust if multiple intervals (e.g., add time1min if labeled)\n  const intervals = {\n    '1h': {\n      meta: data.meta || {},\n      values: data.values || [],\n      status: data.status || 'unknown'\n    }\n  };\n\n  // News articles (fallback empty if missing)\n  const news = {\n    totalResults: data.totalResults || 0,\n    articles: data.articles || []\n  };\n\n  return {\n    json: {\n      symbol,\n      intervals,\n      news\n    }\n  };\n});\n\nreturn formatted;  // Output array for aggregate/indicators"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2688,
        32
      ],
      "id": "203dcd07-905d-42a6-aabf-8d8b8213ea9f",
      "name": "CleanMergedData"
    }
  ],
  "pinData": {},
  "connections": {
    "TelegramInputTrigger": {
      "main": [
        [
          {
            "node": "FilterBotMessages",
            "type": "main",
            "index": 0
          },
          {
            "node": "PreserveChatId",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "NormalizeInputText": {
      "main": [
        [
          {
            "node": "ParseSymbolsToArray",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ParseSymbolsToArray": {
      "main": [
        [
          {
            "node": "LoopValidateSymbols",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LoopValidateSymbols": {
      "main": [
        [
          {
            "node": "CheckSymbolRegex",
            "type": "main",
            "index": 0
          },
          {
            "node": "PreserveSymbol",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AddRateLimitWait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CheckSymbolRegex": {
      "main": [
        [
          {
            "node": "CollectInvalidSymbol",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ValidateSymbolTwelveData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CheckSymbolAPIResult": {
      "main": [
        [
          {
            "node": "MergeValidationResults",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "CollectInvalidSymbol",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AddRateLimitWait": {
      "main": [
        [
          {
            "node": "LoopValidateSymbols",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MergeValidationResults": {
      "main": [
        [
          {
            "node": "FormatValidSymbols",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SendErrorMessage": {
      "main": [
        [
          {
            "node": "MergeValidationResults",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "FormatValidSymbols": {
      "main": [
        [
          {
            "node": "ManualSymbolSplit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch1MinTimeSeries": {
      "main": [
        [
          {
            "node": "RateLimit1Min",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch15MinTimeSeries": {
      "main": [
        [
          {
            "node": "RateLimit15Min",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch1HourTimeSeries": {
      "main": [
        [
          {
            "node": "RateLimit1Hr",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FetchNewsArticles": {
      "main": [
        [
          {
            "node": "RateLimitNews",
            "type": "main",
            "index": 0
          },
          {
            "node": "MergeFetchResults",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "CollectInvalidSymbol": {
      "main": [
        [
          {
            "node": "SendErrorMessage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ValidateSymbolTwelveData": {
      "main": [
        [
          {
            "node": "RateLimitWait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AggregateDataIntervals": {
      "main": [
        [
          {
            "node": "ComputeTechnicalIndicators",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ComputeTechnicalIndicators": {
      "main": [
        [
          {
            "node": "MergeSentimentResults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AnalyzeNewsSentimentChain": {
      "main": [
        [
          {
            "node": "MergeSentimentResults",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "GrokSentimentModel": {
      "ai_languageModel": [
        [
          {
            "node": "AnalyzeNewsSentimentChain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "MergeSentimentResults": {
      "main": [
        [
          {
            "node": "AggregateSentiments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AggregateSentimentScores": {
      "main": [
        [
          {
            "node": "GenerateTradeRecommendationAgent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GenerateTradeRecommendationAgent": {
      "main": [
        [
          {
            "node": "SendTradeRecommendation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GrokRecommendationModel": {
      "ai_languageModel": [
        [
          {
            "node": "GenerateTradeRecommendationAgent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HandleIncomingChatMessage": {
      "main": [
        [
          {
            "node": "AnalyzeNewsSentimentChain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PreserveSymbol": {
      "main": [
        [
          {
            "node": "ValidateSymbolTwelveData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FilterBotMessages": {
      "main": [
        [
          {
            "node": "NormalizeInputText",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "RateLimitWait": {
      "main": [
        [
          {
            "node": "CheckSymbolAPIResult",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RateLimit1Min": {
      "main": [
        [
          {
            "node": "MergeFetchResults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RateLimit15Min": {
      "main": [
        [
          {
            "node": "MergeFetchResults",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "RateLimit1Hr": {
      "main": [
        [
          {
            "node": "MergeFetchResults",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "RateLimitNews": {
      "main": [
        [
          {
            "node": "AnalyzeNewsSentimentChain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AggregateTimeSeries": {
      "main": [
        [
          {
            "node": "AggregateDataIntervals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AggregateSentiments": {
      "main": [
        [
          {
            "node": "AggregateSentimentScores",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PreserveChatId": {
      "main": [
        [
          {
            "node": "NormalizeInputText",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ManualSymbolSplit": {
      "main": [
        [
          {
            "node": "Fetch15MinTimeSeries",
            "type": "main",
            "index": 0
          },
          {
            "node": "Fetch1MinTimeSeries",
            "type": "main",
            "index": 0
          },
          {
            "node": "Fetch1HourTimeSeries",
            "type": "main",
            "index": 0
          },
          {
            "node": "FetchNewsArticles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MergeFetchResults": {
      "main": [
        [
          {
            "node": "CleanMergedData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CleanMergedData": {
      "main": [
        [
          {
            "node": "AggregateTimeSeries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false,
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "fc003c9e-586d-40f8-9512-59fe5f729114",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "e528253e88e4586541d2eb06c1ec5fdac21c84cfb5afc416ee840c43e0960980"
  },
  "id": "WcPP6HpwTVEUFdgu",
  "tags": []
}
